     1	#include <stdio.h>
     2	#include <setjmp.h>
     3	#include <stdlib.h>
     4	#include <signal.h>
     5	
     6	/* output from a sample run:
     7	
     8	   SIGFPE is defined as 8
     9	   Two integers: 100 10
    10	   100 / 10 == 10
    11	   Two integers: 100 0
    12	        Control to jumper: signal status == 8.
    13	   Two integers: 100 4
    14	   100 / 4 == 25
    15	   Two integers:  ;; I entered Control-C to terminate program
    16	*/
    17	
    18	/* Define a jump buffer to handle error conditions.
    19	   Data type jmp_buf defined in setjmp.h.
    20	*/
    21	static jmp_buf env;       /* file scope, type jmp_buf is defined in setjmp.h */
    22	
    23	void jumper(int);         /* callback for SIGFPE errors */
    24	void divisionInt(void);   /* alternative to void divisionInt() */
    25	int guard(void);          /* guards divisonInt */
    26	
    27	void trace_and_die(const char* msg) {
    28	  fprintf(stderr, "%s", msg); /* stderr is harder to redirect than stdout */
    29	  exit(EXIT_FAILURE);         /* -1 in stdlib.h */
    30	}
    31	
    32	int main() {
    33	  /* Trap signals generated by arithmetic errors such as 
    34	     division by zero. The statement
    35	     
    36	     signal(SIGINT, SIG_IGN);
    37	
    38	     would instruct the program to ignore (SIG_IGN) interrupts such
    39	     as hitting Control-C while the program is in execution.
    40	
    41	     In this example, we want to suppress floating-point exceptions
    42	     from the system and instead handle the matter ourselves.
    43	
    44	     Withtout this setup, the division of, say, 100 by 0 would generate
    45	     a "floating-point exception" and terminate execution.
    46	  */
    47	 
    48	  printf("SIGFPE is defined as %i\n", SIGFPE);
    49	
    50	  signal(SIGFPE, jumper); /* enable a jump to jumper function on FPE */
    51	  while (0 == guard())    /* loop until error occurs */
    52	    ;                     /* empty statement follows call to guard() */
    53	  return 0;
    54	}
    55	
    56	
    57	
    58	
    59	
    60	
    61	
    62	/* Jump out of this function to the jump destination,
    63	   which is the point after the call to setjmp. In
    64	   our case, the jump point occurs right after the
    65	   if-test in function guard.
    66	*/
    67	void jumper(int status) {
    68	  printf("\t Control to jumper: signal status == %d.\n", status);
    69	  longjmp(env, 1);  /* 1 indicates what setjmp would have returned.
    70			       If successful, longjmp forces control to return
    71			       to the next statement after setjmp, in this case
    72			       a call to divisionInt.
    73			     */
    74	  /* Executed only if longjmp fails, which shouldn't happen. */
    75	  trace_and_die("longjmp returned: trouble\n");
    76	}
    77	
    78	/* Set a jump point for return from an error  condition, in this case 
    79	   an error resulting from a floating-point operation. The function
    80	   signal is invoked in main to trap such errors. Return 0 (ok) if the 
    81	   floating-point operation succeeds; otherwise, the nonlocal jump
    82	   triggered by longjmp intervenes.
    83	*/
    84	int guard(void) {
    85	  /* Set jump point, which is right after the while-test. Here's
    86	     a summary of what happens when the two integers are, say,
    87	     12 and 0, which causes the FPE "division by zero" error. 
    88	        
    89	        -- the signal(SIGFPE, jumper) establishes the jumper 
    90	           function as the callback (event handler) should a
    91	           exception occur
    92	
    93	        -- the guard function (we're in it) is called from the
    94	           infinitie while loop as a test. guard returns 0 to
    95	           signal OK
    96	
    97	        -- right before calling divisionInt, guard saves the
    98	           current environment, including all of the information
    99	           about the error handling
   100	
   101	        -- if the divisionInt function triggers a division by zero
   102	           exception, then jumper is called by the system
   103	
   104	        -- jumper invokes longjmp with the saved environment. the
   105	           jump is "long" in that divisionInt does not return, as
   106	           normal, to the printf statement at the bottom of guard;
   107	           instead, control resumes immediately after the call to
   108	           guard(), which is the empty statement that is the body
   109	           of the while loop.
   110	
   111	
   112	
   113	
   114	
   115	
   116	
   117	
   118	
   119	
   120	
   121	
   122	     Here's output from a sample run to illustrate:
   123	
   124		Two integers: 12 5
   125		12 / 5 == 2
   126		Right after divisionInt()....
   127	
   128		Two integers: 12 4
   129		12 / 4 == 3
   130		Right after divisionInt()....
   131	
   132		Two integers: 12 0
   133		Control to jumper: signal status == 8.
   134	
   135		Two integers: 12 2
   136		12 / 2 == 6
   137		Right after divisionInt()....
   138		Two integers: ^C
   139	  */
   140	  setjmp(env);
   141	  divisionInt();
   142	  printf("Right after divisionInt()....\n");
   143	  return 0;
   144	}
   145	
   146	/* Scan the standard input for two floats and
   147	   divide the first by the second.
   148	*/
   149	void divisionInt(void) {
   150	  int n1, n2;
   151	  printf("Two integers: ");
   152	  scanf("%i %i", &n1, &n2);
   153	  printf("%i / %i == %i\n", n1, n2, n1 / n2);
   154	}
   155	
