     1	#include <stdio.h>
     2	#include <string.h>
     3	
     4	#define BuffSize (1000)
     5	#define MaxIndent (12)
     6	
     7	int main() {
     8	  
     9	  unsigned char buffer[BuffSize + 1];
    10	  while (fgets(buffer, BuffSize, stdin) != 0) {
    11	    unsigned char* ptr = buffer;
    12	    unsigned int n = 0;
    13	
    14	    while (isspace(*ptr)) ptr++;
    15	    while (isdigit(*ptr) && ++n < MaxIndent) ptr++;
    16	    if (*ptr == '\t') ptr++;
    17	    printf("%s", ptr);
    18	  }
    19	  return 0;
    20	}
    21	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    22	
    23	#include <stdio.h>
    24	#include <setjmp.h>
    25	#include <stdlib.h>
    26	#include <signal.h>
    27	
    28	/* output from a sample run:
    29	   
    30	SIGFPE is defined as 8
    31	Two integers: 100 10
    32	100 / 10 == 10
    33	Two integers: 100 0
    34	Control to jumper: signal status == 8.
    35	Two integers: 100 4
    36	100 / 4 == 25
    37	Two integers:  ;; I entered Control-C to terminate program
    38	
    39	*/
    40	
    41	/* Define a jump buffer to handle error conditions.
    42	   Data type jmp_buf defined in setjmp.h.
    43	  */
    44	static jmp_buf env;       /* file scope; type is defined in setjmp.h */
    45	
    46	void jumper(int);         /* callback for SIGFPE errors */
    47	void divisionInt(void);   /* alternative to void divisionInt() */
    48	int guard(void);          /* guards divisonInt */
    49	
    50	void trace_and_die(const char* msg) {
    51	  fprintf(stderr, msg);
    52	  exit(EXIT_FAILURE);
    53	}
    54	
    55	
    56	
    57	
    58	
    59	
    60	
    61	
    62	int main() {
    63	  /* Trap signals generated by arithmetic errors such as
    64	     division by zero. The statement
    65	
    66	     signal(SIGINT, SIG_IGN);
    67	     
    68	     would instruct the program to ignore (SIG_IGN) interrupts such
    69	     as hitting Control-C while the program is in execution.
    70	     In this example, we want to suppress floating-point exceptions
    71	     from the system and instead handle the matter ourselves.
    72	     Withtout this setup, the division of, say, 100 by 0 would generate
    73	     a "floating-point exception" and terminate execution. */
    74	  signal(SIGFPE, jumper);
    75	  printf("SIGFPE is defined as %i\n", SIGFPE);
    76	  
    77	  /* Loop until error condition occurs. */
    78	  while (0 == guard())
    79	    ;
    80	  return 0;
    81	}
    82	
    83	/* Jump out of this function to the jump destination,
    84	   which is the point after the call to setjmp. In
    85	   our case, the jump point occurs right after the
    86	   if-test in function guard. */
    87	void jumper(int status) {
    88	  printf("\t Control to jumper: signal status == %d.\n", status);
    89	  longjmp(env, 1);  /* 1 indicates with setjmp would have returned.
    90			       If successful, longjmp forces control to return
    91			       to the next statement after setjmp, in this case
    92			       a call to divisionInt. */
    93	  /* This code is executed only if longjmp fails. Normally, longjmp
    94	     does not return. */
    95	  trace_and_die("longjmp returned: trouble\n");
    96	}
    97	
    98	/* Set a jump point for return from an error  condition, in this case
    99	   an error resulting from a floating-point operation. The function
   100	   signal is invoked in main to trap such errors. Return 0 (ok) if the
   101	   floating-point operation succeeds; otherwise, the nonlocal jump
   102	   of longjmp intervenes. */
   103	int guard(void) {
   104	  /* Set jump point, which is right after the if-test */
   105	  setjmp(env);
   106	  divisionInt();
   107	  return 0;
   108	}
   109	
   110	/* Scan the standard input for two floats and
   111	   divide the first by the second. */
   112	void divisionInt(void) {
   113	  int n1, n2;
   114	  printf("Two integers: ");
   115	  scanf("%i %i", &n1, &n2);
   116	  printf("%i / %i == %i\n", n1, n2, n1 / n2);
   117	}
