## C calling conventions and gotchas

#include <stdio.h>

int by_val(int n, int m) { 
  n += 1; /* arg changed, not original */
  m -= 1; /* ditto */
  return n * m;
}

int by_ptr(int* n, int* m) {
  *n += 1; /* original changed */
  *m -= 1; /* ditto */
  return *n * *m;
}

int by_ptr_ptr(int** p1, int** p2) {
  int n1 = **p1;
  int n2 = **p2;
  return (n1 + 1) * (n2 - 1);
}

void dump(int a1, int a2, int a3) {
  printf("1st num: %i\n2nd num: %i\n3rd num: %i\n",
	 a1, a2, a3);
}

void dump_array(const int* p, unsigned len) {
  unsigned i;
  for (i = 0; i < len; i++) printf("%i ", p[i]);
  printf("\n");
}

typedef struct Emp {
  char     fname[40 + 1];
  char     lname[40 + 1];
  char     dept[20 + 1];
  float    sal;
  char     address[120 + 1];
  char     boss[40 + 1];
  unsigned married;
} Emp;

void pass_struct1(Emp e) { /* terrible */
  /* sizeof(Emp) == sizeof(e) */
  printf("%lu bytes passed to pass_struct1...\n", sizeof(e));
}
void pass_struct2(Emp* e) { /* now we're talking */
  printf("%lu bytes passed to pass_struct2...\n", sizeof(e));
}

int main() {
  int n = 27, m = 10;
  int r = by_val(n, m);
  dump(n, m, r);
  printf("\n");

  r = by_ptr(&n, &m);
  dump(n, m, r);
  printf("\n");

  /* what you can't do in Java */
  int *p = &n;
  int *q = &m;
  r = by_ptr_ptr(&p, &q);
  dump(n, m, r);
  printf("\n");

  /* arrays take care of themselves */
  unsigned array[ ] = {1, 2, 3, 4};
  dump_array(array, 4); /* address of array[0] is passed as argument */
  printf("\n");

  Emp e;
  pass_struct1(e);  /* terrible */
  pass_struct2(&e);
  
  return 0;
}
/* Output:
1st num: 27
2nd num: 10
3rd num: 252

1st num: 28
2nd num: 9
3rd num: 252

1st num: 28
2nd num: 9
3rd num: 232

1 2 3 4 

276 bytes passed to pass_struct1...
8 bytes passed to pass_struct2...
 */
;;;

## Sorting

#include <stdio.h>
#include <stdlib.h>

#define HowMany  (16)
#define Mod     (100)

void dump(const char* msg, int a[], unsigned len) {
  printf("%s\n", msg);

  unsigned i;
  for (i = 0; i < len; i++) printf("%i ", a[i]);
  printf("\n");
}







/* Assumed semantics for returned value:
   
   0   -- the compared values are equal
   < 0 -- the first precedes the second
   > 0 -- the second precedes the first
 */
int comp(const void* p1, const void* p2) {
  /* for clarity, break down casting/dereferncing */
  const int* pp1 = (const int*) p1;
  const int* pp2 = (const int*) p2;
  int n1 = *pp1;
  int n2 = *pp2;

  /* sort in ascending order: reverse to sort
     in descending order
  */
  return n1 - n2; 
}

int main() {
  /* seed random number generator with current time */
  srand(time(0)); 
  
  /* populate array with random ints */
  int a[HowMany];
  unsigned i;
  for (i = 0; i < HowMany; i++) a[i] = rand() % Mod;
  dump("Unsorted:", a, HowMany);

  /* sort and dump again */
  qsort(a,           /* array to sort */
	HowMany,     /* length */
	sizeof(int), /* sizeof each element */
	comp);       /* pointer to comparision function */
  dump("\nSorted:", a, HowMany);

  /* binary-search array, which must be sorted in ascending order */
  int key = rand(); /* generate a random key */
  int* result = (int*) bsearch(&key,         /* key */
			       a,            /* array */
			       HowMany,      /* length */
			       sizeof(int),  /* element size */
			       comp);        /* comparer */
  if (result) printf("\n%i found in array.\n", key);
  else printf("\n%i not found in array.\n", key);

  /* ensure a key that's in the array */
  key = a[2];
  result = (int*) bsearch(&key,         /* key */
			  a,            /* array */
			  HowMany,      /* length */
			  sizeof(int),  /* element size */
			  comp);        /* comparer */
  if (result) printf("\n%i found in array.\n", key);
  else printf("\n%i not found in array.\n", key);
  
  return 0;
}


/* output:

   Unsorted:
   15 5 45 43 95 68 1 8 89 70 10 88 61 26 46 78 

   Sorted:
   1 5 8 10 15 26 43 45 46 61 68 70 78 88 89 95 
   
   1212608186 not found in array.
   
   8 found in array.
*/
;;;

## Interrupts

#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h>
#include <signal.h>

/* output from a sample run:

   SIGFPE is defined as 8
   Two integers: 100 10
   100 / 10 == 10
   Two integers: 100 0
        Control to jumper: signal status == 8.
   Two integers: 100 4
   100 / 4 == 25
   Two integers:  ;; I entered Control-C to terminate program
*/

/* Define a jump buffer to handle error conditions.
   Data type jmp_buf defined in setjmp.h.
*/
static jmp_buf env;       /* file scope, type jmp_buf is defined in setjmp.h */
void jumper(int);         /* callback for SIGFPE errors */
void divisionInt(void);   /* alternative to void divisionInt() */
int guard(void);          /* guards divisonInt */
void trace_and_die(const char* msg) {
  fprintf(stderr, "%s", msg); /* stderr is harder to redirect than stdout */
  exit(EXIT_FAILURE);         /* -1 in stdlib.h */
}

int main() {
  /* Trap signals generated by arithmetic errors such as 
     division by zero. The statement     
          signal(SIGINT, SIG_IGN);

     would instruct the program to ignore (SIG_IGN) interrupts such
     as hitting Control-C while the program is in execution.

     In this example, we want to suppress floating-point exceptions
     from the system and instead handle the matter ourselves.

     Withtout this setup, the division of, say, 100 by 0 would generate
     a "floating-point exception" and terminate execution.
  */

 
  printf("SIGFPE is defined as %i\n", SIGFPE);

  signal(SIGFPE, jumper); /* enable a jump to jumper function on FPE */
  while (0 == guard())    /* loop until error occurs */
    ;                     /* empty statement follows call to guard() */
  return 0;
}

/* Jump out of this function to the jump destination,
   which is the point after the call to setjmp. In
   our case, the jump point occurs right after the
   if-test in function guard.
*/
void jumper(int status) {
  printf("\t Control to jumper: signal status == %d.\n", status);
  longjmp(env, 1);  /* 1 indicates what setjmp would have returned.
		       If successful, longjmp forces control to return
		       to the next statement after setjmp, in this case
		       a call to divisionInt.
		     */
  /* Executed only if longjmp fails, which shouldn't happen. */
  trace_and_die("longjmp returned: trouble\n");
}

/* Set a jump point for return from an error  condition, in this case 
   an error resulting from a floating-point operation. The function
   signal is invoked in main to trap such errors. Return 0 (ok) if the 
   floating-point operation succeeds; otherwise, the nonlocal jump
   triggered by longjmp intervenes.
*/
int guard(void) {
  /* Set jump point, which is right after the while-test. Here's
     a summary of what happens when the two integers are, say,
     12 and 0, which causes the FPE "division by zero" error. 
        
        -- the signal(SIGFPE, jumper) establishes the jumper 
           function as the callback (event handler) should a
           exception occur

        -- the guard function (we're in it) is called from the
           infinitie while loop as a test. guard returns 0 to
           signal OK

        -- right before calling divisionInt, guard saves the
           current environment, including all of the information
           about the error handling

        -- if the divisionInt function triggers a division by zero
           exception, then jumper is called by the system

        -- jumper invokes longjmp with the saved environment. the
           jump is "long" in that divisionInt does not return, as
           normal, to the printf statement at the bottom of guard;
           instead, control resumes immediately after the call to
           guard(), which is the empty statement that is the body
           of the while loop.



     Here's output from a sample run to illustrate:

	Two integers: 12 5
	12 / 5 == 2
	Right after divisionInt()....

	Two integers: 12 4
	12 / 4 == 3
	Right after divisionInt()....

	Two integers: 12 0
	Control to jumper: signal status == 8.

	Two integers: 12 2
	12 / 2 == 6
	Right after divisionInt()....
	Two integers: ^C
  */
  setjmp(env);
  divisionInt();
  printf("Right after divisionInt()....\n");
  return 0;
}

/* Scan the standard input for two floats and
   divide the first by the second.
*/
void divisionInt(void) {
  int n1, n2;
  printf("Two integers: ");
  scanf("%i %i", &n1, &n2);
  printf("%i / %i == %i\n", n1, n2, n1 / n2);
}
;;;;

## Structures and pointers in networking

#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <stdio.h>

typedef struct hostent host_info;

void show_bytes(char* msg, unsigned char* ptr, int how_many) {
  printf("%s\n", msg);
  int i;
  for (i = 0; i < how_many; i++) printf(" %.2x", ptr[i]);
  printf("\n");
}









void dump_host_aux(host_info* host_ptr) {
  if (host_ptr == NULL) return;
  /* Here's the hostent structure layout:

     struct hostent {
        char*    h_name;       ;; official name
        char**   h_aliases;    ;; alias list
        int      h_addrtype;   ;; host address type 
        int      h_length;     ;; length of address 
        char**   h_addr_list;  ;; list of addresses 
     };
  */
  printf("\n");
  printf("Official name: %s\n", host_ptr->h_name);

  printf("Aliases: ");
  int i = 0;
  while (host_ptr->h_aliases[i] != NULL) {
    printf("%.21s\n", host_ptr->h_aliases[i]);
    i++;
  }
  
  int type = host_ptr->h_addrtype;
  const char* type_str = (type == 2) ? "AF_INET" : "AF_INET6";

  printf("Host type: %s\n", type_str);

  printf("Address length: %i\n", host_ptr->h_length);

  printf("Addresses: ");
  i = 0;
  while (host_ptr->h_addr_list[i] != NULL) {
    struct in_addr addr;
    addr.s_addr = *((unsigned int*) host_ptr->h_addr_list[i]);
    if (i > 0) printf("           ");
    printf("%.21s\n", inet_ntoa(addr));
    i++;
  }
  printf("\n");
}

void dump_host(const char* host_name) {
  host_info* host = gethostbyname(host_name);
  dump_host_aux(host);
}

int main() {
  /* host and network byte order */
  int n = 0xabcdef12;
  show_bytes("IA32 int:", (unsigned char*) &n, sizeof(int));
  unsigned u = htonl(n);
  show_bytes("htonl:", (unsigned char*) &u, sizeof(unsigned));
  u = ntohl(u);
  show_bytes("ntohl:", (unsigned char*) &n, sizeof(int));
  /* output:

     IA32 int: 12 ef cd ab
     htonl:    ab cd ef 12
     ntohl:    12 ef cd ab  */

  /* dotted-decimal addresses in network byte order */
  struct in_addr inet_address;
  int flag = inet_aton("140.192.1.6", &inet_address);
  if (flag) {
    unsigned long addr = inet_address.s_addr;
    show_bytes("inet_aton:", (unsigned char*) &addr, sizeof(unsigned long));
    /*
        inet_aton: 8c c0 01 06 ;; 140 192 1 6
    */
  }

  /* some lookup stuff */
  dump_host("condor.depaul.edu");
  dump_host("www.google.com");
  dump_host("www.yahoo.com");
  dump_host("localhost");
  /* output:

    Official name: condor.depaul.edu
    Aliases:
    Host type:AF_INET
    Address length: 4
    Addresses: 140.192.1.6

    Official name: www.l.google.com
    Aliases: www.google.com
    Host type: AF_INET
    Address length: 4
    Addresses: 72.14.203.104
               72.14.203.99

    Official name: www.yahoo.akadns.net
    Aliases: www.yahoo.com
    Host type: AF_INET
    Address length: 4
    Addresses: 68.142.197.66
               68.142.197.74
               68.142.197.79
               68.142.197.82
               68.142.197.84
               68.142.197.85
               68.142.197.87
               68.142.197.90

    Official name: localhost.localdomain
    Aliases: localhost
    Host type: AF_INET
    Address length: 4
    Addresses: 127.0.0.1
  */

  return 0;
}

