
#include <stdio.h>
#include <string.h>

#define BuffSize (1024)
#define MaxIndent (12)

/* 
 Change

   12  This is a numbered line in a handout.
 
 to

   This is a numbered line in a handout.
*/
int main() {
  unsigned char buffer[BuffSize + 1];

  while (fgets(buffer, BuffSize, stdin) != 0) {
    unsigned char* ptr = buffer;
    unsigned int n = 0;

    while (isspace(*ptr)) ptr++;
    while (isdigit(*ptr) && ++n < MaxIndent) ptr++;
    if (*ptr == '\t') ptr++;
    printf("%s", ptr);
  }
  return 0;
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h>
#include <signal.h>

/* output from a sample run:

   SIGFPE is defined as 8
   Two integers: 100 10
   100 / 10 == 10
   Two integers: 100 0
        Control to jumper: signal status == 8.
   Two integers: 100 4
   100 / 4 == 25
   Two integers:  ;; I entered Control-C to terminate program
*/

/* Define a jump buffer to handle error conditions.
   Data type jmp_buf defined in setjmp.h.
*/
static jmp_buf env;       /* file scope, type jmp_buf is defined in setjmp.h */

void jumper(int);         /* callback for SIGFPE errors */
void divisionInt(void);   /* alternative to void divisionInt() */
int guard(void);          /* guards divisonInt */

void trace_and_die(const char* msg) {
  fprintf(stderr, "%s", msg); /* stderr is harder to redirect than stdout */
  exit(EXIT_FAILURE);         /* -1 in stdlib.h */
}

int main() {
  /* Trap signals generated by arithmetic errors such as 
     division by zero. The statement
     
     signal(SIGINT, SIG_IGN);

     would instruct the program to ignore (SIG_IGN) interrupts such
     as hitting Control-C while the program is in execution.

     In this example, we want to suppress floating-point exceptions
     from the system and instead handle the matter ourselves.

     Withtout this setup, the division of, say, 100 by 0 would generate
     a "floating-point exception" and terminate execution.
  */
 
  printf("SIGFPE is defined as %i\n", SIGFPE);

  signal(SIGFPE, jumper); /* enable a jump to jumper function on FPE */
  while (0 == guard())    /* loop until error occurs */
    ;                     /* empty statement follows call to guard() */
  return 0;
}

/* Jump out of this function to the jump destination,
   which is the point after the call to setjmp. In
   our case, the jump point occurs right after the
   if-test in function guard.
*/
void jumper(int status) {
  printf("\t Control to jumper: signal status == %d.\n", status);
  longjmp(env, 1);  /* 1 indicates what setjmp would have returned.
		       If successful, longjmp forces control to return
		       to the next statement after setjmp, in this case
		       a call to divisionInt.
		     */
  /* Executed only if longjmp fails, which shouldn't happen. */
  trace_and_die("longjmp returned: trouble\n");
}

/* Set a jump point for return from an error  condition, in this case 
   an error resulting from a floating-point operation. The function
   signal is invoked in main to trap such errors. Return 0 (ok) if the 
   floating-point operation succeeds; otherwise, the nonlocal jump
   triggered by longjmp intervenes.
*/
int guard(void) {
  /* Set jump point, which is right after the while-test. Here's
     a summary of what happens when the two integers are, say,
     12 and 0, which causes the FPE "division by zero" error. 
        
        -- the signal(SIGFPE, jumper) establishes the jumper 
           function as the callback (event handler) should a
           exception occur

        -- the guard function (we're in it) is called from the
           infinitie while loop as a test. guard returns 0 to
           signal OK

        -- right before calling divisionInt, guard saves the
           current environment, including all of the information
           about the error handling

        -- if the divisionInt function triggers a division by zero
           exception, then jumper is called by the system

        -- jumper invokes longjmp with the saved environment. the
           jump is "long" in that divisionInt does not return, as
           normal, to the printf statement at the bottom of guard;
           instead, control resumes immediately after the call to
           guard(), which is the empty statement that is the body
           of the while loop.

     Here's output from a sample run to illustrate:

	Two integers: 12 5
	12 / 5 == 2
	Right after divisionInt()....

	Two integers: 12 4
	12 / 4 == 3
	Right after divisionInt()....

	Two integers: 12 0
	Control to jumper: signal status == 8.

	Two integers: 12 2
	12 / 2 == 6
	Right after divisionInt()....
	Two integers: ^C
  */
  setjmp(env);
  divisionInt();
  printf("Right after divisionInt()....\n");
  return 0;
}

/* Scan the standard input for two floats and divide the first by the second. */
void divisionInt(void) {
  int n1, n2;
  printf("Two integers: ");
  scanf("%i %i", &n1, &n2);
  printf("%i / %i == %i\n", n1, n2, n1 / n2); /* may trigger FPE */
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#include <stdio.h>

#define N (50)
int main() {
  const float temp = 366.0f;
  const float days_in_year = 365.0f; /* ignore leap years */
  float prob = 1.0f;

  int i;
  for (i = 1; i <= N; i++) {
    prob *= (temp - i) / days_in_year;
    printf("%4i - %5.3f", i, 1.0f - prob);
    if (i % 5 == 0) printf("\n");
  }
  return 0;
}
/* 
 Probabilities of shared birthdays == cache conflict

   1 - 0.000   2 - 0.003   3 - 0.008   4 - 0.016   5 - 0.027
   6 - 0.040   7 - 0.056   8 - 0.074   9 - 0.095  10 - 0.117
  11 - 0.141  12 - 0.167  13 - 0.194  14 - 0.223  15 - 0.253
  16 - 0.284  17 - 0.315  18 - 0.347  19 - 0.379  20 - 0.411
  21 - 0.444  22 - 0.476  23 - 0.507  24 - 0.538  25 - 0.569
  26 - 0.598  27 - 0.627  28 - 0.654  29 - 0.681  30 - 0.706
  31 - 0.730  32 - 0.753  33 - 0.775  34 - 0.795  35 - 0.814
  36 - 0.832  37 - 0.849  38 - 0.864  39 - 0.878  40 - 0.891
  41 - 0.903  42 - 0.914  43 - 0.924  44 - 0.933  45 - 0.941
  46 - 0.948  47 - 0.955  48 - 0.961  49 - 0.966  50 - 0.970

Semantics:

Among N people (for N from 1 through 50), what is the liklihood that
any will share a birthday? This is the cache collision problem. Note
that, with 23 people, the probability of a shared birthday > 50%.
With 50 people, it's almost a certainty.
*/

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


#!/usr/bin/perl -w

# RGB to Cyan-Magenta-Yellow-Black (CMYK) format.
# For instance, "rosy red" is 188-143-143 in RGB but
# 0-45-45-67 in CMYK
sub rgb_to_cmyk_bf {      # bf for "brute force"
    my ($r, $g, $b) = @_; # 3 arguments: red, green, blue
    my ($c, $m, $y) = (255 - $r, 255 - $g, 255 - $b);
    my $k = ($c < $m) ? ($c < $y ? $c : $y)
	              : ($m < $y ? $m : $y);
    for ($c, $m, $y) { 
	$_ -= $k; # subtract $k from each
    }
    return [$c, $m, $y, $k]; # an array reference
}
# Take a GIF image that's 1024 (height) by 768 (width) pixels
# for 1024 * 768 = 786,432 pixels in all. Each pixel has an
# RGB value. GIF images are restricted to 256 colors; hence, 
# 786,432 - 256 = 786,176 of the computations will be redundant.
# So here's a better version: one that _caches_ results.
sub rgb_to_cmyk { 
    my ($r, $g, $b) = @_;

    my $key = join ',', $r, $g, $b; # stringify the three
    # Return if already computed.
    return $cache{$key} if exists $cache{$key};

    my ($c, $m, $y) = (255 - $r, 255 - $g, 255 - $b);
    my $k = ($c < $m) ? ($c < $y ? $c : $y)
	              : ($m < $y ? $m : $y);
    for ($c, $m, $y) { 
	$_ -= $k; # subtract $k from each
    }

    # Otherwise, cache the computed value and return it.
    return $cache{$key} = [$c, $m, $y, $k]; 
}
#  Let f = the amount of time required to call rgb_to_cmyk_bf
#  Let g = the amount of time required for the cache operation
#  Let h = the "hit ratio," the probability that a value has
#          been computed already and therefore is in the cache
#
#  If g > f, there's no point in caching, as g occurs on every call.
#
#  The difference between rgb_to_cmyk_bf and rgb_to_cymk is
#
#       g - hf
#
#  That is, every time you find the goodies in the cache, you
#  save f; and h is the liklihood that you'll find the goodies.
#  At the start, h is 0 but approaches 1 with each cache addition.
#  So if g < hf, caching is worth it.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <stdio.h>

typedef struct hostent host_info;

void show_bytes(char* msg, unsigned char* ptr, int how_many) {
  printf("%s\n", msg);
  int i;
  for (i = 0; i < how_many; i++) printf(" %.2x", ptr[i]);
  printf("\n");
}

void dump_host_aux(host_info* host_ptr) {
  if (host_ptr == NULL) return;
  /* Here's the hostent structure layout:

     struct hostent {
        char*    h_name;       ;; official name
        char**   h_aliases;    ;; alias list
        int      h_addrtype;   ;; host address type 
        int      h_length;     ;; length of address 
        char**   h_addr_list;  ;; list of addresses 
     };
  */
  printf("\n");
  printf("Official name: %s\n", host_ptr->h_name);

  printf("Aliases: ");
  int i = 0;
  while (host_ptr->h_aliases[i] != NULL) {
    printf("%.21s\n", host_ptr->h_aliases[i]);
    i++;
  }
  
  int type = host_ptr->h_addrtype;
  const char* type_str = (type == 2) ? "AF_INET" : "AF_INET6";

  printf("Host type: %s\n", type_str);

  printf("Address length: %i\n", host_ptr->h_length);

  printf("Addresses: ");
  i = 0;
  while (host_ptr->h_addr_list[i] != NULL) {
    struct in_addr addr;
    addr.s_addr = *((unsigned int*) host_ptr->h_addr_list[i]);
    if (i > 0) printf("           ");
    printf("%.21s\n", inet_ntoa(addr));
    i++;
  }
  printf("\n");
}

void dump_host(const char* host_name) {
  host_info* host = gethostbyname(host_name);
  dump_host_aux(host);
}

int main() {

  /* host and network byte order */
  int n = 0xabcdef12;
  show_bytes("IA32 int:", (unsigned char*) &n, sizeof(int));
  unsigned u = htonl(n);
  show_bytes("htonl:", (unsigned char*) &u, sizeof(unsigned));
  u = ntohl(u);
  show_bytes("ntohl:", (unsigned char*) &n, sizeof(int));
  /* output:

     IA32 int: 12 ef cd ab
     htonl:    ab cd ef 12
     ntohl:    12 ef cd ab
  */

  /* dotted-decimal addresses in network byte order */
  struct in_addr inet_address;
  int flag = inet_aton("140.192.1.6", &inet_address);
  if (flag) {
    unsigned long addr = inet_address.s_addr;
    show_bytes("inet_aton:", (unsigned char*) &addr, sizeof(unsigned long));
    /*
        inet_aton: 8c c0 01 06 ;; 140 192 1 6
    */
  }

  /* some lookup stuff */
  dump_host("condor.depaul.edu");
  dump_host("www.google.com");
  dump_host("www.yahoo.com");
  dump_host("localhost");
  /* output:

    Official name: condor.depaul.edu
    Aliases:
    Host type:AF_INET
    Address length: 4
    Addresses: 140.192.1.6

    Official name: www.l.google.com
    Aliases: www.google.com
    Host type: AF_INET
    Address length: 4
    Addresses: 72.14.203.104
               72.14.203.99

    Official name: www.yahoo.akadns.net
    Aliases: www.yahoo.com
    Host type: AF_INET
    Address length: 4
    Addresses: 68.142.197.66
               68.142.197.74
               68.142.197.79
               68.142.197.82
               68.142.197.84
               68.142.197.85
               68.142.197.87
               68.142.197.90

    Official name: localhost.localdomain
    Aliases: localhost
    Host type: AF_INET
    Address length: 4
    Addresses: 127.0.0.1
  */

  return 0;
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h> 

#define BuffSize (4096)

void error_msg(const char* msg, int halt_flag) {
    perror(msg);
    if (halt_flag) exit(-1);
}

int main() {
  
  const int port = 80;  /* default port for a Web server */

  /* a very simple GET request */
  const char* request = 
    "GET /~mkalin/index.html HTTP/1.1\nhost: condor.depaul.edu\n\n";
  /* GET /~mkalin/index.html   ;; first-line in request
     host: condor.depaul.edu   ;; first and only line of header, a hash
     <newline>                 ;; two newlines signal end of header
     <newline>
                               ;; a GET request has no body
  */
  
  int sock, n;
  struct sockaddr_in serv_addr;
  struct hostent* server;
  char buffer[BuffSize + 1];
 
  /* get the server information */
  server = gethostbyname("condor.depaul.edu");
  if (server == NULL) error_msg("No such host.", 1);

  /* create socket descriptor */
  sock = socket(AF_INET,        /* address family */
		SOCK_STREAM,    /* type: in this case, TCP based */
		0);             /* protocol: 0 means get from 2nd arg */
  if (sock < 0) error_msg("Can't get socket descriptor.", 1);

  /* fill in the fields of the server's address structure */
  bzero(&serv_addr, sizeof(serv_addr));  /* zero everything out to begin */
  serv_addr.sin_family = AF_INET;        /* address family */
  /* copy from the hostent structure into the server address structure */
  bcopy((unsigned char*) server->h_addr, 
	(unsigned char*) &serv_addr.sin_addr.s_addr,
	server->h_length);
  serv_addr.sin_port = htons(port); /* host endian to network endian */

  /* try to connect to the server */
  if (connect(sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) < 0) 
    error_msg("Can't connect.", 1);

  /* write to the socket */
  n = write(sock, request, strlen(request));
  if (n < 0) error_msg("Can't write to socket.", 0);

  /* read from the socket and print what comes back from server */
  bzero(buffer, BuffSize + 1);
  n = read(sock, buffer, BuffSize);
  if (n < 0)  error_msg("Can't read from socket.", 0);
  printf("%s\n", buffer);

  if (close(sock) < 0) error_msg("Can't close socket.", 0);

  return 0;
}
/* output

HTTP/1.1 200 OK
Date: Tue, 29 Jun 2010 20:17:43 GMT
Server: Apache/2.2.3 (Red Hat)
Last-Modified: Sun, 30 May 2010 15:18:57 GMT
ETag: "9c4654-7f0-487d1424b7a40"
Accept-Ranges: bytes
Content-Length: 2032
Connection: close
Content-Type: text/html

<html>
<title>Home page</title>

<head>
<style type = "text/css">
    .body  {background-color: rgb(225, 225, 225);}
    .links {text-decoration: none;}
    .bullets {background-color: rgb(225, 225, 225); }
    .raw {background-color: wheat; }
    h3 { color: black;}
    a { text-decoration: none; }
</style>
<title>Textbook and Course Listings</title>
</head>

<body>

<p>
<fieldset><legend>Basics</legend>
<span>Marty Kalin</span><br/>
<span>Professor and Associate Dean, College of Computing and Digital Media</span><br/>
<span>DePaul University</span><br/>
<span>1 East Jackson</span><br/>
<span>Chicago, IL 60604</span><br/>
<p>
<span>PhD, Northwestern University</span>
</p>
</fieldset>
</p>

<p>
<fieldset><legend>Books</legend>
<div><a href="http://oreilly.com/catalog/9780596521127/">
  Java Web Services: Up and Running</a></div>
<div><a HREF="ed3/">Applications Programming in ANSI C (3rd edition)</a><div>
<div><a HREF="cse/">C for Scientists and Engineers</a><div>
<div><a HREF="apc/">Applications Programming in C++</a><div>
<div><a HREF="oop2/">Object-Oriented Programming in C++ (2nd edition)</a><div>
<div><a HREF="oopj/">Object-Oriented Programming in Java</a><div>
</field

*/

