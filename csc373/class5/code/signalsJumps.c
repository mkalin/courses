#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h>
#include <signal.h>

/* output from a sample run:

   SIGFPE is defined as 8
   Two integers: 100 10
   100 / 10 == 10
   Two integers: 100 0
        Control to jumper: signal status == 8.
   Two integers: 100 4
   100 / 4 == 25
   Two integers:  ;; I entered Control-C to terminate program
*/

/* Define a jump buffer to handle error conditions.
   Data type jmp_buf defined in setjmp.h.
*/
static jmp_buf env;       /* file scope, type jmp_buf is defined in setjmp.h */

void jumper(int);         /* callback for SIGFPE errors */
void divisionInt(void);   /* alternative to void divisionInt() */
int guard(void);          /* guards divisonInt */

void trace_and_die(const char* msg) {
  fprintf(stderr, "%s", msg); /* stderr is harder to redirect than stdout */
  exit(EXIT_FAILURE);         /* -1 in stdlib.h */
}

int main() {
  /* Trap signals generated by arithmetic errors such as 
     division by zero. The statement
     
     signal(SIGINT, SIG_IGN);

     would instruct the program to ignore (SIG_IGN) interrupts such
     as hitting Control-C while the program is in execution.

     In this example, we want to suppress floating-point exceptions
     from the system and instead handle the matter ourselves.

     Withtout this setup, the division of, say, 100 by 0 would generate
     a "floating-point exception" and terminate execution.
  */
 
  printf("SIGFPE is defined as %i\n", SIGFPE);

  signal(SIGFPE, jumper); /* enable a jump to jumper function on FPE */
  while (0 == guard())    /* loop until error occurs */
    ;                     /* empty statement follows call to guard() */
  return 0;
}

/* Jump out of this function to the jump destination,
   which is the point after the call to setjmp. In
   our case, the jump point occurs right after the
   if-test in function guard.
*/
void jumper(int status) {
  printf("\t Control to jumper: signal status == %d.\n", status);
  longjmp(env, 1);  /* 1 indicates what setjmp would have returned.
		       If successful, longjmp forces control to return
		       to the next statement after setjmp, in this case
		       a call to divisionInt.
		     */
  /* Executed only if longjmp fails, which shouldn't happen. */
  trace_and_die("longjmp returned: trouble\n");
}

/* Set a jump point for return from an error  condition, in this case 
   an error resulting from a floating-point operation. The function
   signal is invoked in main to trap such errors. Return 0 (ok) if the 
   floating-point operation succeeds; otherwise, the nonlocal jump
   triggered by longjmp intervenes.
*/
int guard(void) {
  /* Set jump point, which is right after the while-test. Here's
     a summary of what happens when the two integers are, say,
     12 and 0, which causes the FPE "division by zero" error. 
        
        -- the signal(SIGFPE, jumper) establishes the jumper 
           function as the callback (event handler) should a
           exception occur

        -- the guard function (we're in it) is called from the
           infinitie while loop as a test. guard returns 0 to
           signal OK

        -- right before calling divisionInt, guard saves the
           current environment, including all of the information
           about the error handling

        -- if the divisionInt function triggers a division by zero
           exception, then jumper is called by the system

        -- jumper invokes longjmp with the saved environment. the
           jump is "long" in that divisionInt does not return, as
           normal, to the printf statement at the bottom of guard;
           instead, control resumes immediately after the call to
           guard(), which is the empty statement that is the body
           of the while loop.

     Here's output from a sample run to illustrate:

	Two integers: 12 5
	12 / 5 == 2
	Right after divisionInt()....

	Two integers: 12 4
	12 / 4 == 3
	Right after divisionInt()....

	Two integers: 12 0
	Control to jumper: signal status == 8.

	Two integers: 12 2
	12 / 2 == 6
	Right after divisionInt()....
	Two integers: ^C
  */
  setjmp(env);
  divisionInt();
  printf("Right after divisionInt()....\n");
  return 0;
}

/* Scan the standard input for two floats and
   divide the first by the second.
*/
void divisionInt(void) {
  int n1, n2;
  printf("Two integers: ");
  scanf("%i %i", &n1, &n2);
  printf("%i / %i == %i\n", n1, n2, n1 / n2);
}

