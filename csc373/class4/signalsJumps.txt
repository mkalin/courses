     1	#include <stdio.h>
     2	#include <setjmp.h>
     3	#include <stdlib.h>
     4	#include <signal.h>
     5	
     6	/* output from a sample run:
     7	
     8	   SIGFPE is defined as 8
     9	   Two integers: 100 10
    10	   100 / 10 == 10
    11	   Two integers: 100 0
    12	        Control to jumper: signal status == 8.
    13	   Two integers: 100 4
    14	   100 / 4 == 25
    15	   Two integers:  ;; I entered Control-C to terminate program
    16	*/
    17	
    18	/* Define a jump buffer to handle error conditions.
    19	   Data type jmp_buf defined in setjmp.h.
    20	*/
    21	static jmp_buf env;       /* file scope; type is defined in setjmp.h */
    22	
    23	void jumper(int);         /* callback for SIGFPE errors */
    24	void divisionInt(void);   /* alternative to void divisionInt() */
    25	int guard(void);          /* guards divisonInt */
    26	
    27	void trace_and_die(const char* msg) {
    28	  fprintf(stderr, msg);
    29	  exit(EXIT_FAILURE);
    30	}
    31	
    32	int main() {
    33	  /* Trap signals generated by arithmetic errors such as 
    34	     division by zero. The statement
    35	     
    36	     signal(SIGINT, SIG_IGN);
    37	
    38	     would instruct the program to ignore (SIG_IGN) interrupts such
    39	     as hitting Control-C while the program is in execution.
    40	
    41	     In this example, we want to suppress floating-point exceptions
    42	     from the system and instead handle the matter ourselves.
    43	
    44	     Withtout this setup, the division of, say, 100 by 0 would generate
    45	     a "floating-point exception" and terminate execution.
    46	  */
    47	  signal(SIGFPE, jumper); 
    48	  printf("SIGFPE is defined as %i\n", SIGFPE);
    49	
    50	  /* Loop until error condition occurs. */
    51	  while (0 == guard())
    52	    ;
    53	  return 0;
    54	}
    55	
    56	
    57	
    58	
    59	
    60	
    61	
    62	/* Jump out of this function to the jump destination,
    63	   which is the point after the call to setjmp. In
    64	   our case, the jump point occurs right after the
    65	   if-test in function guard.
    66	*/
    67	void jumper(int status) {
    68	  printf("\t Control to jumper: signal status == %d.\n", status);
    69	  longjmp(env, 1);  /* 1 indicates with setjmp would have returned.
    70			       If successful, longjmp forces control to return
    71			       to the next statement after setjmp, in this case
    72			       a call to divisionInt.
    73			     */
    74	  /* This code is executed only if longjmp fails. Normally, longjmp
    75	     does not return.
    76	  */
    77	  trace_and_die("longjmp returned: trouble\n");
    78	}
    79	
    80	/* Set a jump point for return from an error  condition, in this case 
    81	   an error resulting from a floating-point operation. The function
    82	   signal is invoked in main to trap such errors. Return 0 (ok) if the 
    83	   floating-point operation succeeds; otherwise, the nonlocal jump
    84	   of longjmp intervenes.
    85	*/
    86	int guard(void) {
    87	  /* Set jump point, which is right after the if-test */
    88	  setjmp(env);
    89	  divisionInt();
    90	  return 0;
    91	}
    92	
    93	/* Scan the standard input for two floats and
    94	   divide the first by the second.
    95	*/
    96	void divisionInt(void) {
    97	  int n1, n2;
    98	  printf("Two integers: ");
    99	  scanf("%i %i", &n1, &n2);
   100	  printf("%i / %i == %i\n", n1, n2, n1 / n2);
   101	}
   102	
